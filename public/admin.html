<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Admin Console</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; background: #f7f7f7; }
    h1 { margin-bottom: 0.5rem; }
    .card { background: #fff; border-radius: 8px; padding: 1.5rem; box-shadow: 0 2px 6px rgba(0,0,0,0.08); }
    label { display: inline-block; margin-right: 0.5rem; }
    input[type="text"] { padding: 0.4rem 0.6rem; border: 1px solid #ccc; border-radius: 4px; }
    button { padding: 0.4rem 0.9rem; border: none; border-radius: 4px; background: #007bff; color: #fff; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
    th, td { padding: 0.6rem; border-bottom: 1px solid #eee; text-align: left; }
    th { background: #fafafa; }
    .status { margin-top: 1rem; font-size: 0.9rem; color: #444; }
    .value-input { width: 100%; box-sizing: border-box; }
    .tabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
    .tab-btn { padding: 0.5rem 1rem; border: 1px solid #ccc; border-radius: 4px; background: #eee; cursor: pointer; color: #333; }
    .tab-btn.active { background: #fff; border-bottom: 2px solid #007bff; color: #000; }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    .flex-row { display: flex; gap: 1rem; flex-wrap: wrap; }
    .flex-row label { margin-right: 0; }
    form { margin-top: 1rem; }
    input[type="number"] { padding: 0.4rem 0.6rem; border: 1px solid #ccc; border-radius: 4px; }
    select { padding: 0.4rem 0.6rem; border: 1px solid #ccc; border-radius: 4px; }
    .form-actions { display: flex; gap: 0.5rem; align-items: center; }
    .token-row { margin: 0.5rem 0 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; }
    .derived-meta { margin-top: 0.5rem; display: flex; gap: 1.5rem; font-weight: 600; }
    .toast {
      position: fixed;
      top: 1rem;
      right: 1rem;
      min-width: 200px;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      color: #fff;
      background: rgba(0, 0, 0, 0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 999;
    }
    .toast.show {
      opacity: 1;
      pointer-events: auto;
    }
    .toast.error {
      background: #c0392b;
    }
    .toast.success {
      background: #2ecc71;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Admin Console</h1>
    <div class="tabs">
      <button class="tab-btn active" data-tab="locationsTab">Locations</button>
      <button class="tab-btn" data-tab="hourlyTab">Hourly</button>
      <button class="tab-btn" data-tab="dailyTab">Daily</button>
      <button class="tab-btn" data-tab="configTab">Config</button>
    </div>

    <div id="locationsTab" class="tab-panel active">
      <h2>Locations</h2>
      <div class="token-row">
        <label for="locationToken">Admin Token:</label>
        <input type="text" id="locationToken" placeholder="Required for add/edit/delete" />
      </div>
      <h3>Add Location</h3>
      <form id="locationForm" class="flex-row">
        <label>Name<input type="text" id="newName" required /></label>
        <label>Latitude<input type="number" step="any" id="newLat" required /></label>
        <label>Longitude<input type="number" step="any" id="newLon" required /></label>
        <label>Time Zone
          <select id="newTz" required></select>
        </label>
        <label>Is Ski Resort?
          <select id="newResort">
            <option value="false">No</option>
            <option value="true">Yes</option>
          </select>
        </label>
        <input type="hidden" id="editingId" />
        <div class="form-actions">
          <button type="submit" id="saveLocationBtn">Add</button>
          <button type="button" id="cancelEditBtn" style="display:none;">Cancel</button>
        </div>
        <div class="derived-meta">
          <div>Country: <span id="derivedCountry">Unknown</span></div>
          <div>Region: <span id="derivedRegion">-</span></div>
        </div>
      </form>

      <form id="locationSearchForm" class="flex-row">
        <label>
          Query:
          <input type="text" id="locationQuery" placeholder="Name contains..." />
        </label>
        <label>
          Resort Only:
          <select id="locationResort">
            <option value="">All</option>
            <option value="true">Yes</option>
            <option value="false">No</option>
          </select>
        </label>
        <button type="submit">Search</button>
      </form>
      <table id="locationsTable" style="display:none;">
        <thead>
          <tr>
            <th>Name</th>
            <th>Country</th>
            <th>Region</th>
            <th>Lat</th>
            <th>Lon</th>
            <th>TZ</th>
            <th>Resort?</th>
            <th></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="locationStatus" class="status"></div>
    </div>

    <div id="hourlyTab" class="tab-panel">
      <h2>Hourly Weather</h2>
      <div class="token-row">
        <label for="hourlyToken">Admin Token:</label>
        <input type="text" id="hourlyToken" placeholder="Optional (only if endpoint secured)" />
      </div>
      <div class="flex-row">
        <label>
          Location:
          <select id="hourlyLocationSelect">
            <option value="">Loading...</option>
          </select>
        </label>
        <label>
          Start Date:
          <input type="date" id="hourlyStartDate" />
        </label>
        <label>
          End Date:
          <input type="date" id="hourlyEndDate" />
        </label>
        <button id="loadHourlyBtn">Load</button>
      </div>
      <table id="hourlyTable" style="display:none;">
        <thead>
          <tr>
            <th>Date/Time</th>
            <th>Temp (°F)</th>
            <th>Feels Like</th>
            <th>Conditions</th>
            <th>Precip (in)</th>
            <th>Snow (in)</th>
            <th>Wind (km/h)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="hourlyStatus" class="status"></div>
    </div>

    <div id="dailyTab" class="tab-panel">
      <h2>Daily Overview</h2>
      <div class="token-row">
        <label for="dailyToken">Admin Token:</label>
        <input type="text" id="dailyToken" placeholder="Optional" />
      </div>
      <div class="flex-row">
        <label>
          Location:
          <select id="dailyLocationSelect">
            <option value="">Loading...</option>
          </select>
        </label>
        <label>
          Start Date:
          <input type="date" id="dailyStartDate" />
        </label>
        <label>
          End Date:
          <input type="date" id="dailyEndDate" />
        </label>
        <label>
          Mode:
          <select id="dailyMode">
            <option value="overview">Overview</option>
            <option value="segments">Segments</option>
          </select>
        </label>
        <button id="loadDailyBtn">Load</button>
      </div>
      <table id="dailyTable" style="display:none;">
        <thead>
          <tr>
            <th>Date</th>
            <th>High (°F)</th>
            <th>Low (°F)</th>
            <th>Conditions</th>
            <th>Precip (in)</th>
            <th>Snow (in)</th>
            <th>Avg Wind (km/h)</th>
            <th>Precip %</th>
            <th>Cloud %</th>
            <th>Hours</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="dailyStatus" class="status"></div>
    </div>

    <div id="configTab" class="tab-panel">
      <h2>Config Constants</h2>
      <div>
        <label for="token">Admin Token:</label>
        <input type="text" id="token" placeholder="Enter token" />
        <button id="loadBtn">Load Config</button>
      </div>
      <table id="configTable" style="display:none;">
        <thead>
          <tr><th>Key</th><th>Description</th><th>Value</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="status" class="status"></div>
    </div>
  </div>
  <div id="toast" class="toast"></div>

  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script>
    const { DateTime } = luxon;
    // Tab handling
    const tabButtons = document.querySelectorAll('.tab-btn');
    tabButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        tabButtons.forEach((b) => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach((panel) => panel.classList.remove('active'));
        btn.classList.add('active');
        const panel = document.getElementById(btn.dataset.tab);
        if (panel) panel.classList.add('active');
      });
    });

    // Config references
    const table = document.getElementById('configTable');
    const tbody = table.querySelector('tbody');
    const statusEl = document.getElementById('status');
    const configTokenInput = document.getElementById('token');
    const locationTokenInput = document.getElementById('locationToken');
    document.getElementById('loadBtn').addEventListener('click', loadConfig);
    const timezoneSelect = document.getElementById('newTz');
    const derivedCountryEl = document.getElementById('derivedCountry');
    const derivedRegionEl = document.getElementById('derivedRegion');
    const latInput = document.getElementById('newLat');
    const lonInput = document.getElementById('newLon');
    const DEFAULT_TIME_ZONE = 'America/Los_Angeles';
    populateTimeZones();
    latInput.addEventListener('blur', fetchDerivedMetadata);
    lonInput.addEventListener('blur', fetchDerivedMetadata);

    async function loadConfig() {
      const token = configTokenInput.value.trim();
      if (!token) {
        return setStatus('Token is required');
      }
      setStatus('Loading...');
      try {
        const res = await fetch('/admin/config', { headers: { 'x-admin-token': token } });
        if (!res.ok) {
          throw new Error('Request failed: ' + res.status);
        }
        const data = await res.json();
        renderTable(data, token);
        setStatus('Loaded ' + data.length + ' entries');
        if (!locationTokenInput.value.trim()) {
          locationTokenInput.value = token;
        }
      } catch (err) {
        setStatus(err.message);
      }
    }

    function renderTable(entries, token) {
      tbody.innerHTML = '';
      entries.forEach((entry) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${entry.key}</td>
          <td>${entry.description || ''}</td>
          <td><input class="value-input" type="text" value="${entry.value}" /></td>
          <td><button>Save</button></td>
        `;
        const input = tr.querySelector('input');
        const button = tr.querySelector('button');
        button.addEventListener('click', async () => {
          button.disabled = true;
          try {
            const res = await fetch('/admin/config/' + entry.key, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'x-admin-token': token,
              },
              body: JSON.stringify({ value: parseValue(input.value) }),
            });
            if (!res.ok) {
              throw new Error('Update failed: ' + res.status);
            }
            setStatus('Saved ' + entry.key);
          } catch (err) {
            setStatus(err.message);
          } finally {
            button.disabled = false;
          }
        });
        tbody.appendChild(tr);
      });
      table.style.display = 'table';
    }

    function parseValue(val) {
      if (val === 'true') return true;
      if (val === 'false') return false;
      const num = Number(val);
      return Number.isNaN(num) ? val : num;
    }

    function setStatus(msg) {
      statusEl.textContent = msg || '';
    }

    // Location references
    const locationTable = document.getElementById('locationsTable');
    const locationBody = locationTable.querySelector('tbody');
    const locationStatus = document.getElementById('locationStatus');
    const locationForm = document.getElementById('locationForm');
    const saveLocationBtn = document.getElementById('saveLocationBtn');
    const cancelEditBtn = document.getElementById('cancelEditBtn');
    const editingIdInput = document.getElementById('editingId');
    const hourlySelect = document.getElementById('hourlyLocationSelect');
    const hourlyTokenInput = document.getElementById('hourlyToken');
    const hourlyStartInput = document.getElementById('hourlyStartDate');
    const hourlyEndInput = document.getElementById('hourlyEndDate');
    const hourlyStatus = document.getElementById('hourlyStatus');
    const hourlyTable = document.getElementById('hourlyTable');
    const hourlyTableBody = hourlyTable.querySelector('tbody');
    const loadHourlyBtn = document.getElementById('loadHourlyBtn');
    const dailySelect = document.getElementById('dailyLocationSelect');
    const dailyTokenInput = document.getElementById('dailyToken');
    const dailyStartInput = document.getElementById('dailyStartDate');
    const dailyEndInput = document.getElementById('dailyEndDate');
    const dailyStatus = document.getElementById('dailyStatus');
    const dailyModeSelect = document.getElementById('dailyMode');
    const dailyTable = document.getElementById('dailyTable');
    const dailyTableBody = dailyTable.querySelector('tbody');
    const loadDailyBtn = document.getElementById('loadDailyBtn');
    const toastEl = document.getElementById('toast');

    document.getElementById('locationSearchForm').addEventListener('submit', (event) => {
      event.preventDefault();
      loadLocations();
    });
    locationForm.addEventListener('submit', submitLocation);
    cancelEditBtn.addEventListener('click', () => {
      resetLocationForm();
      setLocationStatus('Edit cancelled');
    });
    window.addEventListener('pageshow', (event) => {
      if (event.persisted || performance.getEntriesByType('navigation')[0]?.type === 'reload') {
        resetLocationForm();
      }
    });
    loadHourlyLocationsDropdown();
    setDefaultHourlyDates();
    setDefaultDailyDates();
    loadHourlyBtn.addEventListener('click', loadHourlyWeather);
    loadDailyBtn.addEventListener('click', loadDailyWeather);

    async function loadLocations() {
      const query = document.getElementById('locationQuery').value.trim();
      const resort = document.getElementById('locationResort').value;
      const params = new URLSearchParams();
      if (query) params.set('q', query);
      if (resort) params.set('isSkiResort', resort);
      setLocationStatus('Loading locations...');
      try {
        const res = await fetch('/locations?' + params.toString());
        if (!res.ok) throw new Error('Failed to load locations');
        const data = await res.json();
        renderLocations(data);
        setLocationStatus(`Loaded ${data.length} locations`);
      } catch (err) {
        setLocationStatus(err.message);
        showToast(err.message, true);
      }
    }

    function renderLocations(locations) {
      locationBody.innerHTML = '';
      const sorted = [...locations].sort((a, b) => {
        return (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' });
      });
      sorted.forEach((loc) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${loc.name}</td>
          <td>${loc.country || ''}</td>
          <td>${loc.region || ''}</td>
          <td>${loc.lat}</td>
          <td>${loc.lon}</td>
          <td>${loc.tz_iana || ''}</td>
          <td>${loc.isSkiResort ? 'Yes' : 'No'}</td>
          <td>
            <button type="button" class="edit-btn">Edit</button>
            <button type="button" class="delete-btn" data-id="${loc.id}">Delete</button>
          </td>
        `;
        const deleteBtn = tr.querySelector('.delete-btn');
        deleteBtn.addEventListener('click', () => deleteLocation(loc.id));
        const editBtn = tr.querySelector('.edit-btn');
        editBtn.addEventListener('click', () => startEditLocation(loc));
        locationBody.appendChild(tr);
      });
      locationTable.style.display = locations.length ? 'table' : 'none';
    }

    async function deleteLocation(id) {
      if (!id) return;
      if (!confirm('Delete this location?')) return;
      const adminToken = getLocationAdminToken();
      if (!adminToken) {
        setLocationStatus('Admin token is required for deleting locations');
        return;
      }
      setLocationStatus('Deleting location...');
      try {
        const res = await fetch('/locations/' + id, {
          method: 'DELETE',
          headers: { 'x-admin-token': adminToken },
        });
        if (!res.ok) throw new Error('Delete failed');
        setLocationStatus('Deleted location');
        showToast('Location deleted');
        loadLocations();
      } catch (err) {
        setLocationStatus(err.message);
        showToast(err.message, true);
      }
    }

    async function submitLocation(event) {
      event.preventDefault();
      const editingId = editingIdInput.value;
      const adminToken = getLocationAdminToken();
      if (!adminToken) {
        setLocationStatus('Admin token is required for saving locations');
        return;
      }
      const payload = {
        name: document.getElementById('newName').value.trim(),
        lat: Number(latInput.value),
        lon: Number(lonInput.value),
        tz_iana: timezoneSelect.value,
        isSkiResort: document.getElementById('newResort').value === 'true',
      };
      if (!payload.name || Number.isNaN(payload.lat) || Number.isNaN(payload.lon) || !payload.tz_iana) {
        return setLocationStatus('All required fields must be filled');
      }
      setLocationStatus(editingId ? 'Saving location...' : 'Creating location...');
      try {
        const res = await fetch(editingId ? '/locations/' + editingId : '/locations', {
          method: editingId ? 'PUT' : 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-admin-token': adminToken,
          },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || 'Save failed');
        }
        setLocationStatus(editingId ? 'Location updated' : 'Location created');
        showToast(editingId ? 'Location updated successfully.' : 'Location created successfully.');
        resetLocationForm();
        loadLocations();
      } catch (err) {
        setLocationStatus(err.message);
        showToast(err.message, true);
      }
    }

    function startEditLocation(location) {
      document.getElementById('newName').value = location.name || '';
      latInput.value = location.lat ?? '';
      lonInput.value = location.lon ?? '';
      setTimeZoneValue(location.tz_iana);
      document.getElementById('newResort').value = location.isSkiResort ? 'true' : 'false';
      editingIdInput.value = location.id;
      saveLocationBtn.textContent = 'Save';
      cancelEditBtn.style.display = 'inline-block';
      setLocationStatus(`Editing ${location.name}`);
      derivedCountryEl.textContent = location.country || 'Unknown';
      derivedRegionEl.textContent = location.region || '-';
    }

    function resetLocationForm() {
      locationForm.reset();
      document.getElementById('newResort').value = 'false';
      setTimeZoneValue(DEFAULT_TIME_ZONE);
      editingIdInput.value = '';
      saveLocationBtn.textContent = 'Add';
      cancelEditBtn.style.display = 'none';
      derivedCountryEl.textContent = 'Unknown';
      derivedRegionEl.textContent = '-';
    }

    function setLocationStatus(msg) {
      locationStatus.textContent = msg || '';
    }

    function getLocationAdminToken() {
      const explicit = locationTokenInput.value.trim();
      if (explicit) return explicit;
      const fallback = configTokenInput?.value?.trim();
      if (fallback) {
        locationTokenInput.value = fallback;
        return fallback;
      }
      return '';
    }

    function getSelectedLocationTimezone(selectEl) {
      if (!selectEl) return DEFAULT_TIME_ZONE;
      const option = selectEl.options?.[selectEl.selectedIndex];
      return option?.dataset?.tz || DEFAULT_TIME_ZONE;
    }

    async function fetchDerivedMetadata() {
      const lat = parseFloat(latInput.value);
      const lon = parseFloat(lonInput.value);
      if (Number.isNaN(lat) || Number.isNaN(lon)) {
        derivedCountryEl.textContent = 'Unknown';
        derivedRegionEl.textContent = '-';
        return;
      }
      try {
        const token = getLocationAdminToken();
        const headers = token ? { 'x-admin-token': token } : {};
        const res = await fetch(`/locations/lookup?lat=${lat}&lon=${lon}`, { headers });
        if (!res.ok) throw new Error('Lookup failed');
        const data = await res.json();
        derivedCountryEl.textContent = data.country || 'Unknown';
        derivedRegionEl.textContent = data.region || '-';
      } catch (err) {
        derivedCountryEl.textContent = 'Unknown';
        derivedRegionEl.textContent = '-';
      }
    }

    async function loadHourlyLocationsDropdown() {
      try {
        const res = await fetch('/locations?limit=200');
        if (!res.ok) throw new Error('Failed to load locations');
        const data = await res.json();
        const sorted = (data || []).sort((a, b) => (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' }));
        populateLocationSelect(hourlySelect, sorted);
        populateLocationSelect(dailySelect, sorted);
      } catch (err) {
        hourlyStatus.textContent = err.message;
        dailyStatus.textContent = err.message;
        showToast(err.message, true);
      }
    }

    function populateLocationSelect(select, locations) {
      select.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select a location';
      select.appendChild(placeholder);
      (locations || []).forEach((loc) => {
        const option = document.createElement('option');
        option.value = loc.id;
        option.textContent = loc.name || 'Unnamed';
        if (loc.tz_iana) {
          option.dataset.tz = loc.tz_iana;
        }
        select.appendChild(option);
      });
    }

    function setDefaultHourlyDates() {
      const now = new Date();
      const start = new Date(now.getTime() - 24 * 60 * 60 * 1000);
      const end = new Date(now.getTime() + 24 * 60 * 60 * 1000);
      hourlyStartInput.value = formatDateInput(start);
      hourlyEndInput.value = formatDateInput(end);
    }

    function setDefaultDailyDates() {
      const now = new Date();
      const start = new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000);
      const end = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
      dailyStartInput.value = formatDateInput(start);
      dailyEndInput.value = formatDateInput(end);
    }

    function formatDateInput(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function computeDayOffsets() {
      const tz = getSelectedLocationTimezone(hourlySelect);
      return computeOffsetsForRange(hourlyStartInput.value, hourlyEndInput.value, tz);
    }

    async function loadHourlyWeather() {
      const locationId = hourlySelect.value;
      if (!locationId) {
        hourlyStatus.textContent = 'Select a location first';
        return;
      }
      const range = computeDayOffsets();
      const params = new URLSearchParams({ locationId });
      params.set('daysBack', range.daysBack);
      params.set('daysForward', range.daysForward);
      if (range.startEpoch != null) params.set('startDateEpoch', range.startEpoch);
      if (range.endEpoch != null) params.set('endDateEpoch', range.endEpoch);
      hourlyStatus.textContent = 'Loading hourly data...';
      try {
        const headers = {};
        const token = hourlyTokenInput.value.trim();
        if (token) headers['x-admin-token'] = token;
        const res = await fetch('/weather/hourly?' + params.toString(), { headers });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || 'Failed to load hourly data');
        }
        const data = await res.json();
        renderHourlyTable(data?.data || []);
        hourlyStatus.textContent = `Loaded ${data?.count || 0} rows`;
      } catch (err) {
        hourlyStatus.textContent = err.message;
        showToast(err.message, true);
      }
    }

    function renderHourlyTable(rows) {
      const tz = getSelectedLocationTimezone(hourlySelect);
      hourlyTableBody.innerHTML = '';
      rows.forEach((row) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${formatLocationDateTime(row, tz)}</td>
          <td>${row.temp ?? ''}</td>
          <td>${row.feelsLike ?? ''}</td>
          <td>${row.conditions || ''}</td>
          <td>${row.precip ?? ''}</td>
          <td>${row.snow ?? ''}</td>
          <td>${row.windspeed ?? ''}</td>
        `;
        hourlyTableBody.appendChild(tr);
      });
      hourlyTable.style.display = rows.length ? 'table' : 'none';
    }

    async function loadDailyWeather() {
      const locationId = dailySelect.value;
      if (!locationId) {
        dailyStatus.textContent = 'Select a location first';
        return;
      }
      const range = computeDailyOffsets();
      const params = new URLSearchParams({ locationId });
      params.set('daysBack', range.daysBack);
      params.set('daysForward', range.daysForward);
      if (range.startEpoch != null) params.set('startDateEpoch', range.startEpoch);
      if (range.endEpoch != null) params.set('endDateEpoch', range.endEpoch);
      const mode = dailyModeSelect.value || 'overview';
      const endpoint = mode === 'segments' ? '/weather/daily/segments' : '/weather/daily/overview';
      dailyStatus.textContent = 'Loading daily data...';
      try {
        const headers = {};
        const token = dailyTokenInput.value.trim();
        if (token) headers['x-admin-token'] = token;
        const res = await fetch(endpoint + '?' + params.toString(), { headers });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || 'Failed to load daily data');
        }
        const data = await res.json();
        const rows = data?.days || data?.data || [];
        renderDailyTable(rows);
        dailyStatus.textContent = `Loaded ${rows.length} rows`;
      } catch (err) {
        dailyStatus.textContent = err.message;
        showToast(err.message, true);
      }
    }

    function computeDailyOffsets() {
      const tz = getSelectedLocationTimezone(dailySelect);
      return computeOffsetsForRange(dailyStartInput.value, dailyEndInput.value, tz);
    }

    function renderDailyTable(rows) {
      dailyTableBody.innerHTML = '';
      rows.forEach((row) => {
        if (Array.isArray(row.segments) && row.segments.length) {
          row.segments.forEach((segment) => {
            appendDailyRow(segment, `${row.date || row.day || ''} (${segment.label})`);
          });
        } else {
          appendDailyRow(row, row.date || row.day || '');
        }
      });
      dailyTable.style.display = dailyTableBody.children.length ? 'table' : 'none';
    }

    function appendDailyRow(source, label) {
      const conditions = source.summary || source.conditions || source.representativeHour?.conditions || '';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${label}</td>
        <td>${formatNumberValue(source.high ?? source.maxTemp, 0)}</td>
        <td>${formatNumberValue(source.low ?? source.minTemp, 0)}</td>
        <td>${conditions}</td>
        <td>${formatNumberValue(source.precipTotal, 2)}</td>
        <td>${formatNumberValue(source.snowTotal, 2)}</td>
        <td>${formatNumberValue(source.avgWindspeed)}</td>
        <td>${formatPercentValue(source.avgPrecipProb)}</td>
        <td>${formatPercentValue(source.avgCloudCover)}</td>
        <td>${source.hours ?? ''}</td>
      `;
      dailyTableBody.appendChild(tr);
    }

    function showToast(message, isError = false) {
      if (!toastEl) return;
      toastEl.textContent = message;
      toastEl.classList.remove('show', 'error', 'success');
      toastEl.classList.add(isError ? 'error' : 'success');
      requestAnimationFrame(() => {
        toastEl.classList.add('show');
      });
      clearTimeout(showToast._timer);
      showToast._timer = setTimeout(() => {
        toastEl.classList.remove('show');
      }, 3500);
    }

    function populateTimeZones() {
      const zones = readAllTimeZones();
      const offsets = new Map();
      zones.forEach((zone) => {
        const info = buildTimeZoneInfo(zone);
        if (!offsets.has(info.offsetMinutes)) {
          offsets.set(info.offsetMinutes, info);
        }
      });
      const defaultInfo = buildTimeZoneInfo(DEFAULT_TIME_ZONE);
      offsets.set(defaultInfo.offsetMinutes, defaultInfo); // ensure default uses its zone

      const entries = [...offsets.values()].sort((a, b) => a.offsetMinutes - b.offsetMinutes);
      timezoneSelect.innerHTML = entries
        .map((entry) => `<option value="${entry.zone}">${entry.label}</option>`)
        .join('');
      timezoneSelect.value = DEFAULT_TIME_ZONE;
    }

    function readAllTimeZones() {
      if (typeof Intl !== 'undefined' && typeof Intl.supportedValuesOf === 'function') {
        try {
          const zones = Intl.supportedValuesOf('timeZone');
          if (zones?.length) return zones;
        } catch (err) {
          // ignore
        }
      }
      return [
        'America/Los_Angeles',
        'America/Denver',
        'America/Chicago',
        'America/New_York',
        'Europe/London',
        'Europe/Paris',
        'Asia/Tokyo',
        'Australia/Sydney',
      ];
    }

    function buildTimeZoneInfo(zone) {
      const { label, offsetMinutes } = computeOffsetLabel(zone);
      return { zone, label, offsetMinutes };
    }

    function computeOffsetLabel(zone) {
      try {
        const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: zone,
          hour: '2-digit',
          minute: '2-digit',
          timeZoneName: 'shortOffset',
        });
        const parts = formatter.formatToParts(new Date());
        const tzName = parts.find((part) => part.type === 'timeZoneName')?.value || 'GMT';
        const match = tzName.match(/GMT([+-])(\d{1,2})(?::(\d{2}))?/i);
        let offsetMinutes = 0;
        let label = tzName;
        if (match) {
          const sign = match[1] === '-' ? -1 : 1;
          const hours = parseInt(match[2], 10);
          const minutes = parseInt(match[3] || '0', 10);
          offsetMinutes = sign * (hours * 60 + minutes);
          const hh = String(hours).padStart(2, '0');
          const mm = String(minutes).padStart(2, '0');
          label = `GMT${sign === -1 ? '-' : '+'}${hh}:${mm}`;
        }
        return { label: `(${label}) ${zone}`, offsetMinutes };
      } catch (err) {
        return { label: zone, offsetMinutes: 0 };
      }
    }

    function setTimeZoneValue(value) {
      const target = value || DEFAULT_TIME_ZONE;
      if (![...timezoneSelect.options].some((opt) => opt.value === target)) {
        const info = buildTimeZoneInfo(target);
        const opt = document.createElement('option');
        opt.value = target;
        opt.textContent = info.label;
        timezoneSelect.appendChild(opt);
      }
      timezoneSelect.value = target;
    }

    function computeOffsetsForRange(startValue, endValue, timeZone) {
      const zone = timeZone || DEFAULT_TIME_ZONE;
      const now = DateTime.now().setZone(zone).startOf('day');
      const startDt = startValue ? DateTime.fromISO(startValue, { zone }).startOf('day') : null;
      const endDt = endValue ? DateTime.fromISO(endValue, { zone }).endOf('day') : null;
      const daysBack = startDt ? Math.max(0, Math.round(now.diff(startDt, 'days').days)) : 0;
      const daysForward = endDt ? Math.max(0, Math.round(endDt.diff(now, 'days').days)) : 0;
      return {
        daysBack,
        daysForward,
        startEpoch: startDt ? startDt.toUTC().toMillis() : undefined,
        endEpoch: endDt ? endDt.toUTC().toMillis() : undefined,
      };
    }

    function formatNumberValue(value, digits = 1) {
      if (value === undefined || value === null || Number.isNaN(Number(value))) {
        return '';
      }
      return Number(value).toFixed(digits);
    }

    function formatPercentValue(value) {
      if (value === undefined || value === null || Number.isNaN(Number(value))) {
        return '';
      }
      return `${Number(value).toFixed(0)}%`;
    }

    function formatLocationDateTime(row, timeZone) {
      if (!row) return '';
      const epoch = row.dateTimeEpoch ?? row.dateTime ? Date.parse(row.dateTime) : null;
      if (!epoch) return row.dateTime || '';
      const tz = timeZone || getSelectedLocationTimezone(hourlySelect) || DEFAULT_TIME_ZONE;
      return DateTime.fromMillis(epoch, { zone: tz }).toFormat('yyyy-LL-dd HH:mm');
    }
  </script>
</body>
</html>
